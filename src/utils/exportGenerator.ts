import fs from 'fs-extra';
import path from 'path';
import { ProjectConfig, Logo } from '../types/index.js';
import { loadProjectConfig } from './frameworks.js';
import { RegistryManager } from './registry.js';

/**
 * Parse existing components from index.tsx to preserve them
 */
async function parseExistingComponents(indexPath: string): Promise<Array<{name: string, content: string, brandColor: string}>> {
  if (!(await fs.pathExists(indexPath))) {
    return [];
  }

  const content = await fs.readFile(indexPath, 'utf-8');
  const components: Array<{name: string, content: string, brandColor: string}> = [];
  
  // Regex to match component functions and extract SVG content
  const componentRegex = /export function (\w+Logo)\(\{[^}]*\}\s*(?::\s*LogoProps)?\)\s*\{[^}]*return\s*\(\s*(.*?)\s*\)\s*\}/gs;
  
  let match;
  while ((match = componentRegex.exec(content)) !== null) {
    const componentName = match[1];
    const svgContent = match[2].trim();
    
    // Extract brand color from the component definition
    const colorMatch = content.match(new RegExp(`export function ${componentName}\\(\\{[^}]*color = '([^']*)'`));
    const brandColor = colorMatch ? colorMatch[1] : '#000000';
    
    components.push({
      name: componentName,
      content: svgContent,
      brandColor
    });
  }
  
  return components;
}

/**
 * Generate React component files for logos
 */
export async function generateExportFile(projectPath: string = process.cwd()): Promise<void> {
  const projectConfig = await loadProjectConfig(projectPath);
  
  if (!projectConfig) {
    // Throw a clear error instead of silently returning
    throw new Error('No project configuration found. Run "logocn init" first to enable component generation.');
  }

  const logoDir = path.join(projectPath, projectConfig.logoDirectory);
  const isTypeScript = projectConfig.typescript;
  const indexFileName = isTypeScript ? 'index.tsx' : 'index.jsx';
  const indexPath = path.join(logoDir, indexFileName);

  // Ensure logo directory exists
  if (!(await fs.pathExists(logoDir))) {
    return;
  }

  // Parse existing components to preserve them
  const existingComponents = await parseExistingComponents(indexPath);

  // Get all SVG files for new components
  const files = await fs.readdir(logoDir);
  const svgFiles = files
    .filter(file => file.endsWith('.svg'))
    .sort()
    .map(file => ({
      filename: file,
      name: path.basename(file, '.svg'),
      key: path.basename(file, '.svg').toLowerCase().replace(/[^a-z0-9]/g, '')
    }));

  // Create a map of existing component names for deduplication
  const existingComponentNames = new Set(existingComponents.map(c => c.name));

  // Get brand colors from registry for new components
  const registry = new RegistryManager();
  const logoColors: Record<string, string> = {};
  
  // Filter out SVG files that already have components
  const newSvgFiles = svgFiles.filter(({ key }) => {
    const componentName = `${capitalize(key)}Logo`;
    return !existingComponentNames.has(componentName);
  });
  
  for (const { name } of newSvgFiles) {
    const logo = await registry.findByName(name);
    if (logo) {
      logoColors[name] = logo.hex;
    }
  }

  // If we have no existing components and no new SVG files, remove the index file
  if (existingComponents.length === 0 && newSvgFiles.length === 0) {
    if (await fs.pathExists(indexPath)) {
      await fs.remove(indexPath);
    }
    return;
  }

  // Generate single file with all React components (existing + new)
  await generateSingleComponentFile(existingComponents, newSvgFiles, projectConfig, projectPath, logoColors);
}

/**
 * Generate a single file with all React components using streaming for scalability
 */
async function generateSingleComponentFile(
  existingComponents: Array<{name: string, content: string, brandColor: string}>,
  newSvgFiles: Array<{ filename: string; name: string; key: string }>,
  projectConfig: ProjectConfig,
  projectPath: string,
  logoColors: Record<string, string>
): Promise<void> {
  const logoDir = path.join(projectPath, projectConfig.logoDirectory);
  const isTypeScript = projectConfig.typescript;
  const indexFileName = isTypeScript ? 'index.tsx' : 'index.jsx';
  const indexPath = path.join(logoDir, indexFileName);
  
  // Create write stream for scalability with large numbers of logos
  const writeStream = fs.createWriteStream(indexPath);
  
  // Write header
  writeStream.write(`/**
 * Logo components - Auto-generated by LogoCN
 * Do not edit this file manually
 * 
 * Usage:
 *   import { ReactLogo } from '@/components/logos'
 *   <ReactLogo size={48} />
 *   <ReactLogo size={48} color="#FF0000" />
 */

import * as React from 'react'

`);

  // Add TypeScript interface if needed
  if (isTypeScript) {
    writeStream.write(`export interface LogoProps extends React.SVGProps<SVGSVGElement> {
  size?: number | string
  color?: string
  width?: number | string
  height?: number | string
}

`);
  }

  // Write existing components first
  for (const { name: componentName, content: svgContent, brandColor } of existingComponents) {
    // Write the existing component directly with preserved content and color
    const componentCode = isTypeScript 
      ? `export function ${componentName}({ 
  size = 24,
  color = '${brandColor}',
  width, 
  height, 
  ...props 
}: LogoProps) {
  return (
    ${svgContent}
  )
}

`
      : `export function ${componentName}({ 
  size = 24,
  color = '${brandColor}',
  width, 
  height, 
  ...props 
}) {
  return (
    ${svgContent}
  )
}

`;
    
    writeStream.write(componentCode);
  }

  // Process new SVG files to generate new components
  for (const { filename, name, key } of newSvgFiles) {
    // Read SVG content
    const svgPath = path.join(logoDir, filename);
    const svgContent = await fs.readFile(svgPath, 'utf-8');
    
    // Clean up SVG content (remove <?xml> declaration if present)
    const cleanedSvg = svgContent.replace(/<\?xml.*?\?>/g, '').trim();
    
    // Generate component
    const componentName = `${capitalize(key)}Logo`;
    
    // Get brand color (default to black if not found)
    const brandColor = logoColors[name] ? `#${logoColors[name]}` : '#000000';
    
    // Remove width/height from SVG if present
    let processedSvg = cleanedSvg
      .replace(/width="[^"]*"/g, '')
      .replace(/height="[^"]*"/g, '');
    
    // Add React props to SVG with color support
    processedSvg = processedSvg.replace(
      /<svg([^>]*)>/,
      '<svg$1 width={width || size} height={height || size} fill={color} {...props}>'
    );
    
    // Write component to stream with brand color as default
    const componentCode = isTypeScript 
      ? `export function ${componentName}({ 
  size = 24,
  color = '${brandColor}',
  width, 
  height, 
  ...props 
}: LogoProps) {
  return (
    ${processedSvg}
  )
}

`
      : `export function ${componentName}({ 
  size = 24,
  color = '${brandColor}',
  width, 
  height, 
  ...props 
}) {
  return (
    ${processedSvg}
  )
}

`;
    
    writeStream.write(componentCode);
  }
  
  // Close stream and wait for it to finish
  await new Promise<void>((resolve, reject) => {
    writeStream.end();
    writeStream.on('finish', resolve);
    writeStream.on('error', reject);
  });
  
  // Clean up old individual component files if they exist
  // This happens after the index file is fully written
  const allFiles = await fs.readdir(logoDir);
  for (const file of allFiles) {
    // Remove old individual .tsx/.jsx files (we now use a single index file)
    if ((file.endsWith('.tsx') || file.endsWith('.jsx')) && file !== indexFileName) {
      const filePath = path.join(logoDir, file);
      await fs.remove(filePath);
    }
  }
  
  // Also remove old index.ts if it exists (we now use index.tsx)
  const oldIndexPath = path.join(logoDir, 'index.ts');
  if (await fs.pathExists(oldIndexPath) && isTypeScript) {
    await fs.remove(oldIndexPath);
  }
}

/**
 * Capitalize first letter and handle numeric prefixes
 * For logos starting with numbers, prefix with "Lcn" for valid JavaScript identifiers
 */
function capitalize(str: string): string {
  // Check if string starts with a number
  if (/^\d/.test(str)) {
    // Prefix with "Lcn" for LogoCN branding
    return 'Lcn' + str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Get the export file path for a project
 */
export async function getExportFilePath(projectPath: string = process.cwd()): Promise<string | null> {
  const projectConfig = await loadProjectConfig(projectPath);
  
  if (!projectConfig) {
    return null;
  }

  const indexFileName = projectConfig.typescript ? 'index.tsx' : 'index.jsx';
  return path.join(projectPath, projectConfig.logoDirectory, indexFileName);
}

/**
 * Check if export file exists
 */
export async function exportFileExists(projectPath: string = process.cwd()): Promise<boolean> {
  const exportFilePath = await getExportFilePath(projectPath);
  
  if (!exportFilePath) {
    return false;
  }

  return fs.pathExists(exportFilePath);
}