import fs from 'fs-extra';
import path from 'path';
import { ProjectConfig, Logo } from '../types/index.js';
import { loadProjectConfig } from './frameworks.js';
import { RegistryManager } from './registry.js';

/**
 * Generate React component files for logos
 */
export async function generateExportFile(projectPath: string = process.cwd()): Promise<void> {
  const projectConfig = await loadProjectConfig(projectPath);
  
  if (!projectConfig) {
    // No project config, skip generation
    return;
  }

  const logoDir = path.join(projectPath, projectConfig.logoDirectory);

  // Ensure logo directory exists
  if (!(await fs.pathExists(logoDir))) {
    return;
  }

  // Get all SVG files
  const files = await fs.readdir(logoDir);
  const svgFiles = files
    .filter(file => file.endsWith('.svg'))
    .sort()
    .map(file => ({
      filename: file,
      name: path.basename(file, '.svg'),
      key: path.basename(file, '.svg').toLowerCase().replace(/[^a-z0-9]/g, '')
    }));

  // Always generate/regenerate the index file
  // If no SVG files exist, we need to create an empty index file or remove it
  if (svgFiles.length === 0) {
    // Remove the index file if no logos exist
    const isTypeScript = projectConfig.typescript;
    const indexFileName = isTypeScript ? 'index.tsx' : 'index.jsx';
    const indexPath = path.join(logoDir, indexFileName);
    
    if (await fs.pathExists(indexPath)) {
      await fs.remove(indexPath);
    }
    return;
  }

  // Get brand colors from registry
  const registry = new RegistryManager();
  const logoColors: Record<string, string> = {};
  
  for (const { name } of svgFiles) {
    const logo = await registry.findByName(name);
    if (logo) {
      logoColors[name] = logo.hex;
    }
  }

  // Generate single file with all React components
  await generateSingleComponentFile(svgFiles, projectConfig, projectPath, logoColors);
}

/**
 * Generate a single file with all React components using streaming for scalability
 */
async function generateSingleComponentFile(
  svgFiles: Array<{ filename: string; name: string; key: string }>,
  projectConfig: ProjectConfig,
  projectPath: string,
  logoColors: Record<string, string>
): Promise<void> {
  const logoDir = path.join(projectPath, projectConfig.logoDirectory);
  const isTypeScript = projectConfig.typescript;
  const indexFileName = isTypeScript ? 'index.tsx' : 'index.jsx';
  const indexPath = path.join(logoDir, indexFileName);
  
  // Create write stream for scalability with large numbers of logos
  const writeStream = fs.createWriteStream(indexPath);
  
  // Write header
  writeStream.write(`/**
 * Logo components - Auto-generated by LogoCN
 * Do not edit this file manually
 * 
 * Usage:
 *   import { ReactLogo } from '@/components/logos'
 *   <ReactLogo size={48} />
 *   <ReactLogo size={48} color="#FF0000" />
 */

import * as React from 'react'

`);

  // Add TypeScript interface if needed
  if (isTypeScript) {
    writeStream.write(`export interface LogoProps extends React.SVGProps<SVGSVGElement> {
  size?: number | string
  color?: string
}

`);
  }

  // Process each logo one at a time to avoid loading all into memory
  for (const { filename, name, key } of svgFiles) {
    // Read SVG content
    const svgPath = path.join(logoDir, filename);
    const svgContent = await fs.readFile(svgPath, 'utf-8');
    
    // Clean up SVG content (remove <?xml> declaration if present)
    const cleanedSvg = svgContent.replace(/<\?xml.*?\?>/g, '').trim();
    
    // Generate component
    const componentName = `${capitalize(key)}Logo`;
    
    // Get brand color (default to black if not found)
    const brandColor = logoColors[name] ? `#${logoColors[name]}` : '#000000';
    
    // Remove width/height from SVG if present
    let processedSvg = cleanedSvg
      .replace(/width="[^"]*"/g, '')
      .replace(/height="[^"]*"/g, '');
    
    // Add React props to SVG with color support
    processedSvg = processedSvg.replace(
      /<svg([^>]*)>/,
      '<svg$1 width={width || size} height={height || size} fill={color} {...props}>'
    );
    
    // Write component to stream with brand color as default
    const componentCode = isTypeScript 
      ? `export function ${componentName}({ 
  size = 24,
  color = '${brandColor}',
  width, 
  height, 
  ...props 
}: LogoProps) {
  return (
    ${processedSvg}
  )
}

`
      : `export function ${componentName}({ 
  size = 24,
  color = '${brandColor}',
  width, 
  height, 
  ...props 
}) {
  return (
    ${processedSvg}
  )
}

`;
    
    writeStream.write(componentCode);
  }
  
  // Close stream and wait for it to finish
  await new Promise<void>((resolve, reject) => {
    writeStream.end();
    writeStream.on('finish', resolve);
    writeStream.on('error', reject);
  });
  
  // Clean up old individual component files if they exist
  // This happens after the index file is fully written
  const allFiles = await fs.readdir(logoDir);
  for (const file of allFiles) {
    // Remove old individual .tsx/.jsx files (we now use a single index file)
    if ((file.endsWith('.tsx') || file.endsWith('.jsx')) && file !== indexFileName) {
      const filePath = path.join(logoDir, file);
      await fs.remove(filePath);
    }
  }
  
  // Also remove old index.ts if it exists (we now use index.tsx)
  const oldIndexPath = path.join(logoDir, 'index.ts');
  if (await fs.pathExists(oldIndexPath) && isTypeScript) {
    await fs.remove(oldIndexPath);
  }
}

/**
 * Capitalize first letter and handle numeric prefixes
 * For logos starting with numbers, prefix with "Lcn" for valid JavaScript identifiers
 */
function capitalize(str: string): string {
  // Check if string starts with a number
  if (/^\d/.test(str)) {
    // Prefix with "Lcn" for LogoCN branding
    return 'Lcn' + str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Get the export file path for a project
 */
export async function getExportFilePath(projectPath: string = process.cwd()): Promise<string | null> {
  const projectConfig = await loadProjectConfig(projectPath);
  
  if (!projectConfig) {
    return null;
  }

  const indexFileName = projectConfig.typescript ? 'index.tsx' : 'index.jsx';
  return path.join(projectPath, projectConfig.logoDirectory, indexFileName);
}

/**
 * Check if export file exists
 */
export async function exportFileExists(projectPath: string = process.cwd()): Promise<boolean> {
  const exportFilePath = await getExportFilePath(projectPath);
  
  if (!exportFilePath) {
    return false;
  }

  return fs.pathExists(exportFilePath);
}